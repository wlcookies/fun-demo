## Thread基础

每个线程表示一条执行流，有自己的程序计数器，有自己的栈，线程之间可以共享内存，它们可以操作相同的对象

- id
- name
- priority 优先级（1~10）默认5
- state
    - `NEW` 没有调用start的线程状态
    - `TERMINATED` 线程运行结束后状态
    - `RUNNABLE`
      调用start后线程在执行run方法且没有阻塞时状态，不过，RUNNABLE不代表CPU一定在执行该线程的代码，可能正在执行也可能在等待操作系统分配时间片，只是它没有在等待其他条件。
    - `BLOCKED、WAITING、TIMED_WAITING` 都表示线程被阻塞了，在等待一些条件
- isAlive() 是否活着，线程被启动后，run方法运行结束前，返回值都是true
- daemon 是否daemon线程，一般是其他线程的辅助线程（GC回收线程）
- sleep
- Thread.yield() 让出CPU时间片，告诉系统调度器，目前不需要占用CPU，可以让其他线程执行
- join() 可以让执行此线程的线程等待其执行完毕在结束，在等待过程中可能被中断，中断了会报`Interrupted-Exception`
- join(millis)

## 竞态条件

多个线程访问和操作同一个对象时，最终执行结果与时序有关，可能正确可能不对

## 内存可见性

在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。在单线程的程序中，这一般不是问题，但在多线程的程序中，尤其是在有多CPU的情况下，这就是严重的问题。一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没从内存读。

## 原子性操作

- synchronized 同步代码块、同步方法方法
- volatile 原子变量
- lock 显示锁

### synchronized

保护的是对象不是代码

用于 `静态方法`、`实例方法`、`代码块`

#### synchronized 可重入性

对同一个执行线程，它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用。

#### synchronized 内存可见性

保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。这一点有个轻量级的**volatile**可以实现，修饰变量

#### 死锁

线程间相互等待锁，谁也执行不下去。如何避免：

- 避免在持有一个锁的同时去申请另一个锁，如果需要多个锁，应该按流程顺序申请
- **显式锁接口Lock**，它支持尝试获取锁（tryLock）和带时间限制的获取锁方法，使用这些方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。

## 同步容器

线程安全、没有迭代问题、没有复合问题、性能高

- CopyOnWriteArrayList
- ConcurrentHashMap
- ConcurrentLinkedQueue
- ConcurrentSkipListSet

## 线程基本协作机制（wait/notify）

### 多线程协作场景

#### Java带的阻塞队列

- 接口BlockingQueue和BlockingDeque
- 基于数组的实现类ArrayBlockingQueue
- 基于链表的实现类LinkedBlockingQueue和LinkedBlockingDeque
- 基于堆的实现类PriorityBlockingQueue。

#### 生产者/消费者协作模式

生产者线程、消费者线程，通过共享队列相互协作，生产者将数据或任务放到队列上，而消费者从队列上取数据或任务，如果队列长度有限，在队列满的时候，生产者需要等待，而在队列为空的时候，消费者需要等待。

#### 同时开始

类似运动员比赛，在听到比赛开始枪响后同时开始，在一些程序，尤其是模拟仿真程序中，要求多个线程能同时开始

#### 等待结果

主从协作模式也是一种常见的协作模式，主线程将任务分解为若干子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕。

#### 异步结果

在主从协作模式中，主线程手工创建子线程的写法往往比较麻烦，一种常见的模式是将子线程的管理封装为异步调用，异步调用马上返回，但返回的不是最终的结果，而是一个一般称为Future的对象，通过它可以在随后获得最终的结果。

#### 集合点

类似于学校或公司组团旅游，在旅游过程中有若干集合点，比如出发集合点，每个人从不同地方来到集合点，所有人到齐后进行下一项活动，在一些程序，比如并行迭代计算中，每个线程负责一部分计算，然后在集合点等待其他线程完成，所有线程到齐后，交换数据和计算结果，再进行下一次迭代

### wait/notify

- `wait` 等待（释放锁），可以被中断，中断抛InterruptedException，线程调用了`wait()`
  ，线程会被放入条件队列中阻塞，表示当前线程执行不下去了需要等待一个条件，这个条件自己改变不了，需要其他线程调用notify，notify做的事是，将线程从条件队列中移除并唤醒

-

它们被不同的线程调用，但共享相同的锁和条件等待队列（相同对象的synchronized代码块内），它们围绕一个共享的条件变量进行协作，这个条件变量是程序自己维护的，当条件不成立时，线程调用wait进入条件等待队列，另一个线程修改了条件变量后调用notify，调用wait的线程唤醒后需要重新检查条件变量。从多线程的角度看，它们围绕共享变量进行协作，从调用wait的线程角度看，它阻塞等待一个条件的成立。我们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。

- 只能有一个条件判断，通过显示锁可以解决等待条件复杂的情况

#### wait具体过程

虽然在synchronized内，但是wait一旦调用了，则该线程会释放对象锁

1. 把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为`WAITING`或`TIMED_WAITING`。
2. 等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时，要重新竞争对象锁：
    - 如果能够获得锁，线程状态变为`RUNNABLE`，并从wait调用中返回
    - 否则，该线程加入对象锁等待队列，线程状态变为`BLOCKED`，只有在获得锁后才会从wait调用中返回

注意：`wait`需要条件检查

```java
synchronized (this){
        // 检查变量a
        while(!a){
        wait();
        }
        }
```

## 线程中断

每个线程都有一个标记位，表示该线程是否被中断

- `isInterrupted()` 返回对应线程的中断标志位是否为true
- `interrupt()` 表示中断对应的线程
- `static interrupted()` 返回当前线程的中断标志位是否为true，但它还有一个重要的副作用，就是清空中断标志位，也就是说，连续两次调用interrupted()
  ，第一次返回的结果为true，第二次一般就是false（除非同时又发生了一次中断）

### 线程中断反应

- `RUNNABLE`：线程在运行或具备运行条件只是在等待操作系统调度
- `WAITING/TIMED_WAITING`：线程在等待某个条件或超时
- `BLOCKED`：线程在等待锁，试图进入同步块
- `NEW/TERMINATED`：线程还未启动或已结束

### 如何正确的取消

Future和ExecutorService cancel()




